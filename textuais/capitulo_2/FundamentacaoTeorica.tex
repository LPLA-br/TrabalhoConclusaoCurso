
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%      Fundamentação Teórica      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Deve haver um tópico para cada assunto abordado na sua pesquisa.

\section{\textbf{FUNDAMENTAÇÃO TEÓRICA}}
    \label{cha:fundamentacao-teorica}
    % remove nome do capítulo do cabeçalho

   % A fundamentação teórica é a base de qualquer pesquisa, oferecendo o embasamento
   % conceitual necessário para entender e explorar um determinado tema. Ela consiste
   % na REVISÃO E SÍNTESE CRÍTICA de teorias, estudos anteriores e informações relevantes
   % que sustentam a investigação em questão. Essa seção é crucial para mostrar a
   % importância e a originalidade do estudo, fornecendo um conjunto de conceitos e
   % ideias que ajudam na análise dos resultados. Modelos teóricos, conceitos-chave,
   % abordagens metodológicas e estudos anteriores são abordados para fornecer um suporte
   % consistente à pesquisa. 

    %INTRODUÇÃO À SEÇÃO

    Esta seção apresenta uma breve revisão das obras mais importantes de
    autores que tratam acerca dos métodos capazes de mitigar os efeitos
    adversos presentes em práticas, em padrões e arquiteturas, que mostraram-se
    danosas à qualidade do \textit{software} sob o paradigma de programação
    orientada a objetos \ac{oop}.

    % orientação a objetos - pilares
    Antes de avançar sobre conceitos arquiteturais e de padrões de projetos,
    deve-se, primeiro, observar aos fundamentos intrínsecos do paradigma sobre
    o qual dispõe-se a trabalhar sobre.
    
    O conceito de paradigma é introduzido por \citeonline{floyd2007paradigms}
    como sendo: "um padrão, um exemplo com o qual as coisas são feitas". O mesmo autor
    deixara claro, ao discutir acerca dos paradigmas de sua época, que o conceito, no
    âmbito do desenvolvimento de software, consiste na forma como programas são feitos.

    Os paradigmas surgiram concomitantemente com o desenvolvimento de linguagens de
    programação, em especial nas de alto nível que abstraiam a implementação binária
    direta de instruções, possibilitando uma implementação mais humana e menos complexa
    \cite[p.~8-]{Sammet1969languages}.

    Inicialmente houve o surgimento, com o desenvolvimento da arquitetura de Von Neumann,
    do primeiro paradigma, o Imperativo que trazia os conceitos fundamentais de estado
    e ação modificante do estado. Sua influência é, até hoje, enorme e serviu de base
    para paradigmas posteriores \cite[p.~1]{jungthon2009paradigmas}.

    Com o aumento de complexidade dos sistemas, surge o paradigma estruturado
    que definia a sequência, iteração e decisão como sendo as partes
    fundamentais de qualquer programa implementável \cite{Dijkstra1972structured}.

    Por fim, a orientação a objetos, inicialmente implantadas nas linguagens Simula 1962 e
    Smalltalk 1972, traz os conceitos de objeto como uma abstração de qualquer elemento
    da vida real que interage separadamente com outros por meio de "mensagens"
    \cite[p.~52-55]{rentsch1982object}.

    O paradigma orientado a objetos originou, de acordo com a síntese de outros
    autores presente em \citeonline{kasture2019pillars}, os quatros pilares
    fundamentais sobre da implementação \ac{oop} definidos como:

    \begin{itemize}
      \item{ Abstração \- capacidade de representar um subconjunto de atributos e comportamentos de uma entidade real }
      \item{ Encapsulamento \- controle de acesso externo a atributos e comportamentos privados de um objeto }
      \item{ Herança \- capacidade de extensão por superconjunto de atributos e comportamentos }
      \item{ Polimorfismo \- capacidade de mutação de comportamentos por sobrescrita }
    \end{itemize}

%   Superconjuntos dos fundamentos OOP

    O paradigma \ac{oop} adjunto de seus fundamentais pilares possibilitou o
    desenvolvimento de princípios e padrões de projeto. Ambos sendo peças
    metodológicas possuidoras de características relativamente periódicas que
    extendem os quatro pilares fundamentais possibilitando solução ou mitigação
    de problemas existentes no desenho \ac{oop} \cite[p.~19-20]{gamma1993design}.

    Por sua vez, os princípios, mais abragentes e abstratos, influênciam um
    contexto mais fundamental e abstrato. Embora não constituam obrigação são,
    de fato, recomendações cuja credibilidade fundamenta-se na experiência de
    profissionais de longa data, aplicabilidade ampla em inúmeras tecnologias
    implementacionais, consequências relativamente previsíveis.

%   Um parágrafo para:
%   SOLID, Object Calisthenics
%   DRY Dont Repeat yourself(reduzir duplicação de conhecimento),
%   KISS Keep It Simple, Stupid, SoC Separation of concerns
%   Least Astonishment(comportamento previsível ao usuário), FF Fail Fast

    O SOLID, produto da análise de \citeonline[et all.]{uncleBob2017} trata, em
    cinco pontos interconexos, acerca da forma de se modelar um abstrato
    conjunto de classes. A responsabilidade única da classe com entidade,
    priorização da ação de extender sobre a ação de modificar, preservação da
    relação de substituição entre classe base e derivada em herança e a
    inversão de dependências por contratos abstratos.

    O \textit{Object Calithenics} de \citeonline{ObjectCalisthenics2008} trás
    sete caminhos pelos quais um sistema conforma-se-á mais com os quatro
    pilares fundamentais do paradigma \ac{oop}.

    Os padrões, responsáveis por tratarem a forma como as classes/objetos
    interagem, possuem quatro propriedades fundamentais que os definem: Um nome
    padronizado, um problema comum a resolver, a especificação geral da solução
    que resolve ou mitiga o problema alvo e as consequências positivas e
    negativas de adotá-lo \cite[p.~19 et al.]{gamma1993design}.

    Como exemplo, o padrão \textit{Adapter} constitui-se como um objeto
    cujos os métodos são capazes de traduzir chamadas entre código cliente
    e o código servidor.

%   Distânciar-se mais padrões, por possui escopo muito amplo, e focar em arquiteturas.

    No âmbito das arquitetura de sistemas houve o aprimoramento contínuo de
    conceitos que promovem desacoplamento por meio da separação de
    responsabilidades. O objetivo geral constituiu-se das seguintes
    propriedades ideais desejadas, como apontado por \cite[p. 202]{uncleBob2017}:

    \begin{itemize}
      \item{ Arquitetura que independe do frameworks para funcionar. }
      \item{ Regras de negócio podem ser testadas sem interferência de camadas superiores ou inferiores. }
      \item{ Idependência de Interface de Usuário onde ela pode mudar sem interferir o resto do sistema. }
      \item{ Idependência de banco de dados onde sua mudança não interfere nas regras de negócio.  }
      \item{ Independência total das regras de negócio. }
    \end{itemize}

    Arquiteturalmente houve o desenvolvimento initerrupto de conceitos
    promovedores do separação de responsabilidades principalmente em
    arquiteturas baseadas em camadas. Chegou-se à conclusão universal de que
    todo o software possui, em seu código fonte, dois elementos distinguíveis
    categoricamente. Cada autor o definiu de formas levemente diferentes.

    \citeonline[p. 51]{evans2004domain} refere-se ao domínio em separação das
    demais camadas satélites que permitem a funcionalidade de tal domínio ao
    usuário final.

    \begin{figure}[h]
      \centering
      \caption{ Modelo de Camadas Notáveis em Sistemas de Acordo com \ac{ddd}. }
      \includegraphics[scale=0.8]{lib/layered-ddd.png}
      \source{ Erick Evans 2004 {\imprimirdata}}
      \label{fig:figura}
    \end{figure}

    Semelhantemente, \citeonline{alistairHexagonal2005}, em seu artigo original, define
    um padrão majoritariamente comoposto de classes adaptadoras que possibilitam a separação
    do que ele chamou de "aplicação" do \textit{outside world} "mundo externo".

    \begin{figure}[h]
      \centering
      \caption{ Modelo Hexagonal com Classes Adaptadoras Interligando Domínio e Dependências. }
      \includegraphics[scale=1.2]{lib/hexagonal-original.png}
      \source{ Alistair Cockburn 2005 {\imprimirdata}}
      \label{fig:figura}
    \end{figure}

    Mais a frente \citeonline[p.~189]{uncleBob2017} define categorias separadas
    em \textit{business rules} "regras de negócio" e demais partes satélites
    que possibilitam que tais regras sejam úteis na forma de uma aplicação
    utilizável.

    Em conclusão sintética, tais autores trataram acerca de um mesmo problema
    que possui um conjunto de caracteristicas semelhantes e satélites do
    conceito de dependência. O \textit{software} constroi-se envolto em
    um meio que o permite ser útil ao usuário final. O meio, de forma genérica, 
    possuidor das seguintes caracteristicas:

    \begin{itemize}
        \item{ Interfaces gráficas. }
        \item{ Persistência da informação (bancos de dados). }
        \item{ Comunicação entre computadores em redes TCP/IP. }
        \item{ Segurança da informação por criptografia e hashing. }
        \item{ Especificidades da infraestrutura em que a aplicação executa. }
        \item{ Manipulação de dispositivos computacionais de entrada ou saída. }
    \end{itemize}

    \citeonline[p. 52]{evans2004domain} aponta que o \textit{software} pode, 
    em processos de desenvolvimento descuidados, espalhar as regras do domínio
    de negócios sobre algumas ou todas partes sobrelistadas.


    %TODO: apontar como não sendo foco o criticismo
    Apesar todas as visões apresentadas dos parágrafos superiores aparentarem
    ser ótimas, há, de fato, um criticismo na forma pela qual tais orientações
    evoluem em complexidade nos projetos acarretando em problemas de
    complexidade e excesso de engenharia como causa e o desenvolvimento menos
    ágil em função da maior massividade de código fonte como consequência
    \cite{redGreenwp2015}.

    % hexagonal:Alistair Cockburn, livro: Hexagonal Architecture: Ports and Adapters
    % Growing Object Oriented Software with Tests
    % DCI:  James Coplien e Trygve Reenskaug
    % BCE:  Ivar Jacobson, livro: Object Oriented Software Engineering: A Use-Case
    %       Driven Approach.


%   PRINCIPAIS AUTORES
%     Bass, Clements, Kazman ( referência teórica fundamental da arquitetura de software )
%       Software Architecture in Practice
%
%     Robert Cecil Martin (Uncle Bob)
%       Clean Architecture, Implementing clean architecture, Clean architecture with .NET
%
%     Willian Vance
%       Clean Architecture
%     
%     Martin Fowler
%       ?
%
%     Erick Evans ( design de domínio )
%       Domain Driven Design
%     Vaughn Vernon
%       Implementing DDD
%
%     Buschmann et all. ( padrões arquiteturais )
%       Pattern-Oriented Software Architecture


    % ÚLTIMO TÓPICO
    % \input{textuais/capitulo_2/sub-topicos/TrabalhosRelacionados}
\newpage
