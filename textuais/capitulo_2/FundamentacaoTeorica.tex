
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%      Fundamentação Teórica      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Deve haver um tópico para cada assunto abordado na sua pesquisa.

\section{\textbf{FUNDAMENTAÇÃO TEÓRICA}}
    \label{cha:fundamentacao-teorica}
    % remove nome do capítulo do cabeçalho

   % A fundamentação teórica é a base de qualquer pesquisa, oferecendo o embasamento
   % conceitual necessário para entender e explorar um determinado tema. Ela consiste
   % na REVISÃO E SÍNTESE CRÍTICA de teorias, estudos anteriores e informações relevantes
   % que sustentam a investigação em questão. Essa seção é crucial para mostrar a
   % importância e a originalidade do estudo, fornecendo um conjunto de conceitos e
   % ideias que ajudam na análise dos resultados. Modelos teóricos, conceitos-chave,
   % abordagens metodológicas e estudos anteriores são abordados para fornecer um suporte
   % consistente à pesquisa. 

    %INTRODUÇÃO À SEÇÃO

    Esta seção apresenta uma breve revisão das obras mais importantes de autores
    acerca da separação de responsabilidades, desacoplamento e design ruim em
    softwares.

    % orientação a objetos - pilares
    Antes de avançar sobre conceitos arquiteturais e de padrões de projetos,
    deve-se, primeiro, observar aos fundamentos intrínsecos do paradigma sobre
    o qual dispõe-se a trabalhar sobre.
    
    O conceito de paradigma é introduzido por \citeonline{floyd2007paradigms}
    como sendo: "um padrão, um exemplo com o qual as coisas são feitas". O mesmo autor
    deixara claro, ao discutir acerca dos paradigmas de sua época, que o conceito, no
    âmbito do desenvolvimento de software, consiste na forma como programas são feitos.

    Os paradigmas surgiram concomitantemente com o desenvolvimento de liguagens de
    programação, em especial nas de alto nível que abstraiam a implementação binária
    direta de instruções, possibilitando uma implementação mais humana e menos complexa
    \cite[p.~8-]{Sammet1969languages}.

    Inicialmente há o surgimento, com o desenvolvimento da arquitetura de Von Neumann,
    do primeiro paradigma, o Imperativo que trazia os conceitos fundamentais de estado
    e ação modificante do estado. Sua influência é, até hoje, enorme e serviu de núcleo
    para paradigmas posteriores \cite[p.~1]{jungthon2009paradigmas}.

    Com o aumento de complexidade dos sistemas, surge o paradigma estruturado
    que definia a sequência, iteração e decisão como sendo as partes
    fundamentais de qualquer programa implementável
    \cite{Dijkstra1972structured}.

    Por fim, a orientação a objetos, inicialmente implantadas nas linguagens Simula(1962) e
    Smalltalk(1972), traz os conceitos de objeto como uma abstração de qualquer elemento
    da vida real que interage separadamente com outros por meio de "mensagens"
    \cite[p.~52-55]{rentsch1982object}.

    O paradigma orientado a objetos originou, de acordo com a síntese de outros autores presente em
    \citeonline{kasture2019pillars}, quatros pilares fundamentais sobre a implementação definidos como:

    \begin{itemize}
      \item{ Abstração \- capacidade de representar um subconjunto de atributos e comportamentos de uma entidade real }
      \item{ Encapsulamento \- controle de acesso externo a atributos e comportamentos privados de um objeto }
      \item{ Herança \- capacidade de extensão por superconjunto de atributos e comportamentos }
      \item{ Polimorfismo \- capacidade de mutação de comportamentos por sobrescrita }
    \end{itemize}

%   Superconjuntos dos fundamentos OOP

    O paradigma orientado a objetos possibilitou o desenvolvimento de padrões
    de projeto e princípios definidos por procedimentos reprodutíveis e
    possuidores características periódicas que extendem os quatro pilares
    fundamentais possibilitando solução ou mitigação de problemas oriundos do
    design \ac{oop} \cite[p.~19-20]{gamma1993design}.

    Os padrões, responsáveis por tratarem a forma como as classes/objetos
    interagem, possuem quatro propriedades fundamentais que os definem: Um nome
    padrão, um problema que eles propõem-se a resolver, a especificação geral
    da solução que resolve o problema e as consequências positivas e negativas
    de adotá-lo \cite[p.~19 et al.]{gamma1993design}.

    Indo além dos padrões, tem-se princípios, mais abragentes e abstratos,
    aplicam-se em um contexto mais fundamental. Embora não constituam
    obrigação são, de fato, boas recomendações para melhoria de qualidade.
    No cenário atual destacam-se, em nível industrial, o conjunto de cinco regras
    chamado pela sigra SOLID e o seu "detalhamento prático" o \textit{Object calisthenics}
    \cite{ObjectCalisthenics2008, uncleBob2017}.

%   Distânciar-se mais padrões, por possui escopo muito amplo, e focar em arquiteturas.

    No âmbito das arquitetura de sistemas houve o aprimoramento contínuo de
    conceitos que promovem desacoplamento por meio da separação de
    responsabilidades. O objetivo geral constituiu-se das seguintes
    propriedades ideais desejadas, como apontado por \cite[p. 202]{uncleBob2017}:

    \begin{itemize}
      \item{ Arquitetura que independe do frameworks para funcionar. }
      \item{ Regras de negócio podem ser testadas sem interferência de camadas superiores ou inferiores. }
      \item{ Idependência de Interface de Usuário onde ela pode mudar sem interferir o resto do sistema. }
      \item{ Idependência de banco de dados onde sua mudança não interfere nas regras de negócio.  }
      \item{ Independência total das regras de negócio. }
    \end{itemize}

    Arquiteturalmente houve o desenvolvimento initerrupto de conceitos
    promovedores do separação de responsabilidades principalmente em
    arquiteturas baseadas em camadas. Chegou-se à conclusão universal de que
    todo o software possui, em seu código fonte, dois elementos distinguíveis
    categoricamente. Cada autor o definiu de formas levemente diferentes.

    \citeonline[p. 51]{evans2004domain} refere-se ao domínio em separação das
    demais camadas satélites que permitem a funcionalidade de tal domínio ao
    usuário final.

    Semelhantemente, \citeonline{alistairHexagonal2005}, em seu artigo original, define
    um padrão majoritariamente comoposto de classes adaptadoras que possibilitam a separação
    do que ele chamou de "aplicação" do \textit{outside world} \(mundo externo\).

    Mais a frente \citeonline[p. 189]{uncleBob2017} define, mais
    abragentemente, categorias separadas em \textit{business rules} \(regras de
    negócio\) e demais partes satélites que possibilitam que tais regras sejam
    utilizáveis.

    \citeonline[p. 52]{evans2004domain} inicialmente aponta, reiterando o
    motivo pelo qual tantos autores pensam semelhantemente sobre o mesmo problema,
    o comum malefeito oriundo do espalhamento de regras de negócio
    sobre uma ampla área técnica do software que não a do exclusivo domínio
    que possui as regras do negócio a qual a aplicação visa atender.

    Apesar todas as visões apresentadas dos parágrafos superiores aparentarem
    ser ótimas, há, de fato, um criticismo na forma pela qual tais orientações
    evoluem em complexidade nos projetos acarretando em problemas de
    complexidade e excesso de engenharia como causa e o desenvolvimento menos
    ágil em função da maior massividade de código fonte como consequência
    \cite{redGreenwp2015}.

    % hexagonal:Alistair Cockburn, livro: Hexagonal Architecture: Ports and Adapters
    % Growing Object Oriented Software with Tests
    % DCI:  James Coplien e Trygve Reenskaug
    % BCE:  Ivar Jacobson, livro: Object Oriented Software Engineering: A Use-Case
    %       Driven Approach.


%   PRINCIPAIS AUTORES
%     Bass, Clements, Kazman ( referência teórica fundamental da arquitetura de software )
%       Software Architecture in Practice
%
%     Robert Cecil Martin (Uncle Bob)
%       Clean Architecture, Implementing clean architecture, Clean architecture with .NET
%
%     Willian Vance
%       Clean Architecture
%     
%     Martin Fowler
%       ?
%
%     Erick Evans ( design de domínio )
%       Domain Driven Design
%     Vaughn Vernon
%       Implementing DDD
%
%     Buschmann et all. ( padrões arquiteturais )
%       Pattern-Oriented Software Architecture


    % ÚLTIMO TÓPICO
    % \input{textuais/capitulo_2/sub-topicos/TrabalhosRelacionados}
\newpage
