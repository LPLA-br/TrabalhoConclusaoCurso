
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%      Fundamentação Teórica      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Deve haver um tópico para cada assunto abordado na sua pesquisa.

\section{\textbf{FUNDAMENTAÇÃO TEÓRICA}}
    \label{cha:fundamentacao-teorica}
    % remove nome do capítulo do cabeçalho

   % A fundamentação teórica é a base de qualquer pesquisa, oferecendo o embasamento
   % conceitual necessário para entender e explorar um determinado tema. Ela consiste
   % na REVISÃO E SÍNTESE CRÍTICA de teorias, estudos anteriores e informações relevantes
   % que sustentam a investigação em questão. Essa seção é crucial para mostrar a
   % importância e a originalidade do estudo, fornecendo um conjunto de conceitos e
   % ideias que ajudam na análise dos resultados. Modelos teóricos, conceitos-chave,
   % abordagens metodológicas e estudos anteriores são abordados para fornecer um suporte
   % consistente à pesquisa. 

    %INTRODUÇÃO À SEÇÃO

    Esta seção apresenta uma breve revisão das obras mais importantes de autores
    que contribuiram com os esforços pro desacoplamento e contra efeitos adversos
    das dependências em desenvolvimento de software.

    % orientação a objetos - pilares
    Antes de avançar sobre conceitos arquiteturais e de padrões de projetos, deve-se, primeiro,
    observar aos fundamentos intrínsecos do paradigma sobre o qual dispõe-se a trabalhar sobre.
    
    O conceito de paradigma é introduzido por \citeonline{floyd2007paradigms}
    como sendo: "um padrão, um exemplo com o qual as coisas são feitas". O mesmo autor
    deixara claro, ao discutir acerca dos paradigmas de sua época, que o conceito, no
    âmbito do desenvolvimento de software, consiste na forma como programas são feitos.

    Os paradigmas surgiram concomitantemente com o desenvolvimento de liguagens de
    programação, em especial nas de alto nível que abstraiam a implementação binária
    direta de instruções, possibilitando uma implementação mais humana e menos complexa
    \cite[p.~8-]{Sammet1969languages}.

    Inicialmente há o surgimento, com o desenvolvimento da arquitetura de Von Neumann,
    do primeiro paradigma, o Imperativo que trazia os conceitos fundamentais de estado
    e ação modificante do estado. Sua influência é, até hoje, enorme e serviu de núcleo
    para paradigmas posteriores \cite[p.~1]{jungthon2009paradigmas}.

    Com o aumento de complexidade dos sistemas, surge o paradigma estruturado que definia
    a sequência, iteração e decisão como sendo as partes fundamentais de qualquer programa
    implementável \cite{Dijkstra1972structured}.

    Por fim, a orientação a objetos, inicialmente implantadas nas linguagens Simula(1962) e
    Smalltalk(1972), traz os conceitos de objeto como uma abstração de qualquer elemento
    da vida real que interage separadamente com outros por meio de "mensagens"
    \cite[p.~52-55]{rentsch1982object}.

    O paradigma orientado a objetos originou, de acordo com a síntese de outros autores presente em
    \citeonline{kasture2019pillars}, quatros pilares fundamentais sobre a implementação definidos como:

    \begin{itemize}
      \item{ Abstração \- capacidade de representar um subconjunto de atributos e comportamentos de uma entidade real }
      \item{ Encapsulamento \- controle de acesso externo a atributos e comportamentos privados de um objeto }
      \item{ Herança \- capacidade de extensão por superconjunto de atributos e comportamentos }
      \item{ Polimorfismo \- capacidade de mutação de comportamentos por sobrescrita }
    \end{itemize}

%   Superconjuntos dos fundamentos OOP

    O paradigma orientado a objetos possibilitou o desenvolvimento de padrões
    de projeto e princípios definidos por procedimentos reprodutíveis e
    possuidores características periódicas que extendem os quatro pilares
    fundamentais para solução de problemas oriundos do
    desenvolvimento sobre o paradigma \ac{oop}  \cite[p.~19-20]{gamma1993design}.

    Os padrões, responsáveis por tratarem a forma como as classes/objetos
    interagem, possuem quatro propriedades fundamentais que os definem: Um nome
    padrão, um problema que eles propõem-se a resolver, a especificação geral
    da solução que resolve o problema e as consequências positivas e negativas
    de adotá-lo \cite[p.~19 et al.]{gamma1993design}.

    Indo além dos padrões, tem-se princípios, mais abragentes e abstratos,
    aplicam-se em um contexto mais fundamental. Embora não constituam
    obrigação são, de fato, boas recomendações para melhoria de qualidade.
    No cenário atual destacam-se, em nível industrial, o conjunto de cinco regras
    chamado pela sigra SOLID e o seu "detalhamento prático" o \textit{Object calisthenics}
    \cite{ObjectCalisthenics2008, uncleBob2017}.

%   Distânciar-se mais padrões, por possui escopo muito amplo, e focar em arquiteturas.

    No âmbito das arquitetura de sistemas houve o aprimoramento contínuo de
    conceitos que promovem desacoplamento por meio da separação de
    responsabilidades. O objetivo geral constituiu-se das seguintes
    propriedades ideais desejadas, como apontado por \cite[p. 202]{uncleBob2017}:

    \begin{itemize}
      \item{ Arquitetura que independe do frameworks para funcionar. }
      \item{ Regras de negócio podem ser testadas sem interferência de camadas superiores ou inferiores. }
      \item{ Idependência de Interface de Usuário onde ela pode mudar sem interferir o resto do sistema. }
      \item{ Idependência de banco de dados onde sua mudança não interfere nas regras de negócio.  }
      \item{ Independência total das regras de negócio. }
    \end{itemize}

    Arquiteturalmente houve o desenvolvimento initerrupto de conceitos
    promovedores do separação de responsabilidades principalmente em
    arquiteturas baseadas em camadas. Chegou-se à conclusão universal de que
    todo o software possui, em seu código fonte, dois elementos distinguíveis
    categoricamente. Cada autor o definiu de formas levemente diferentes.


    \citeonline[p. ]{evans2004domain} refere-se ao domínio em separação dos
    demais \ac{ui}, \textit{Application} e Infraestrutura.

    Semelhantemente,
    \citeonline[p. 189]{uncleBob2017} define, mais abragentemente, categorias separadas
    em \textit{business rules} (regras de negócio) e demais partes satélites que
    possibilitam que tais regras sejam utilizáveis. 

    \citeonline[52]{evans2004domain} inicialmente aponta o comum problema oriundo
    do espalhamento de regras de negócio sobre uma ampla área de partes
    não significantes ao domínio. propõe, ele, posteriormente, um modelo de
    quatro camadas genéricas: Interface de usuário, aplicação como coordenador
    de ações sen conhecimento de regras de negócio, o domínio como o mantenedor
    e guardião das regras de negócio e a infraestrutura (camada inferior que
    sustenta todas as demais superiores.)

    % hexagonal:Alistair Cockburn, livro: Hexagonal Architecture: Ports and Adapters
    % Growing Object Oriented Software with Tests
    % DCI:  James Coplien e Trygve Reenskaug
    % BCE:  Ivar Jacobson, livro: Object Oriented Software Engineering: A Use-Case
    %       Driven Approach.


%   PRINCIPAIS AUTORES
%     Bass, Clements, Kazman ( referência teórica fundamental da arquitetura de software )
%       Software Architecture in Practice
%
%     Robert Cecil Martin (Uncle Bob)
%       Clean Architecture, Implementing clean architecture, Clean architecture with .NET
%
%     Willian Vance
%       Clean Architecture
%     
%     Martin Fowler
%       ?
%
%     Erick Evans ( design de domínio )
%       Domain Driven Design
%     Vaughn Vernon
%       Implementing DDD
%
%     Buschmann et all. ( padrões arquiteturais )
%       Pattern-Oriented Software Architecture


    % ÚLTIMO TÓPICO
    \input{textuais/capitulo_2/sub-topicos/TrabalhosRelacionados}
\newpage
