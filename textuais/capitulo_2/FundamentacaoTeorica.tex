
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%      Fundamentação Teórica      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Deve haver um tópico para cada assunto abordado na sua pesquisa.

\section{\textbf{FUNDAMENTAÇÃO TEÓRICA}}
    \label{cha:fundamentacao-teorica}
    % remove nome do capítulo do cabeçalho

   % A fundamentação teórica é a base de qualquer pesquisa, oferecendo o embasamento
   % conceitual necessário para entender e explorar um determinado tema. Ela consiste
   % na REVISÃO E SÍNTESE CRÍTICA de teorias, estudos anteriores e informações relevantes
   % que sustentam a investigação em questão. Essa seção é crucial para mostrar a
   % importância e a originalidade do estudo, fornecendo um conjunto de conceitos e
   % ideias que ajudam na análise dos resultados. Modelos teóricos, conceitos-chave,
   % abordagens metodológicas e estudos anteriores são abordados para fornecer um suporte
   % consistente à pesquisa. 

    %INTRODUÇÃO À SEÇÃO

    Esta seção, apresenta uma breve compilação das obras mais importantes de
    autores, nos quais direcionam acerca dos métodos capazes de mitigar os
    efeitos adversos, presentes nas más práticas, que mostraram-se danosas à
    qualidade do \textit{software} sob o paradigma de programação orientação a
    objetos \ac{oop}.

    % orientação a objetos - pilares
    Neste sentido, antes de avançar sobre conceitos arquiteturais e de padrões
    de projetos, deve-se, primeiro, observar aos fundamentos intrínsecos do
    paradigma sobre o qual dispõe-se a trabalhar sobre.
    
    O conceito de paradigma é introduzido por \citeonline{floyd2007paradigms}
    como sendo: "um padrão, um exemplo com o qual as coisas são feitas". O mesmo autor
    deixara claro, ao discutir acerca dos paradigmas de sua época, que o conceito, no
    âmbito do desenvolvimento de software, consiste na forma como programas são feitos.

    Os paradigmas surgiram concomitantemente com o desenvolvimento de linguagens de
    programação, em especial nas de alto nível que abstraiam a implementação binária
    direta de instruções, possibilitando uma implementação mais humana e menos complexa
    \cite[p.~8-]{Sammet1969languages}.

    Inicialmente houve o surgimento, com o desenvolvimento da arquitetura de Von Neumann,
    do primeiro paradigma, o Imperativo que trazia os conceitos fundamentais de estado
    e ação modificante do estado. Sua influência é, até hoje, enorme e serviu de base
    para paradigmas posteriores \cite[p.~1]{jungthon2009paradigmas}.

    Com o aumento de complexidade dos sistemas, surge o paradigma estruturado
    que definia a sequência, iteração e decisão como sendo as partes
    fundamentais de qualquer programa implementável \cite{Dijkstra1972structured}.

    Por fim, a orientação a objetos, inicialmente implantadas nas linguagens
    Simula 1962 e Smalltalk 1972, traz os conceitos de objeto como uma
    abstração de qualquer elemento da vida real que interage separadamente com
    outros por meio de "mensagens" \cite[p.~52-55]{rentsch1982object}. No
    tocante a esse paradigma, ele teve sua origem com síntese de outros autores
    presente em \citeonline{kasture2019pillars}, nos quatros pilares
    fundamentais sobre da implementação \ac{oop} definidos como:

    \begin{itemize}
      \item{ Abstração \- capacidade de representar um subconjunto de atributos e comportamentos de uma entidade real }
      \item{ Encapsulamento \- controle de acesso externo a atributos e comportamentos privados de um objeto }
      \item{ Herança \- capacidade de extensão por superconjunto de atributos e comportamentos }
      \item{ Polimorfismo \- capacidade de mutação de comportamentos por sobrescrita }
    \end{itemize}

    % dos pilares fundamentais para os padrões de projeto.
    Notoriamente, ao definir-se esses pilares, percebe-se que eles
    possibilitaram o desenvolvimento de princípios e padrões de projeto ao
    longo do tempo de aprimoramento técnico do paradigma. Logo, como padrão de
    projeto entende-se uma espécie de peça metodológica de característica
    regular, flexível e aplicável em múltiplos projetos em prol
    de solucionar problemas recorrentes da \ac{oop} \cite[p.~19-20]{gamma1993design}.

    % continuando para os princípios.
    Por sua vez, os princípios, mais abragentes e abstratos, influênciam um
    contexto mais amplo. Embora não constituam obrigação, eles são recomendações cuja
    credibilidade funcional, fundamenta-se na experiência de profissionais
    que trabalham por décadas sobre esse paradigma. Nesse sentido a aplicabilidade
    dos princípios se baseia na: universalidade, idependência de tecnologia
    implementacional e previsibilidade de consequências.

    % Introduz apenas princípios básicos para andamento eficiente
    % da Fundamentação teórica.

    % PRINCÍPIOS DERIVADOS DOS PILARES

    Conseguinte aos princípios, aponta-se o SOLID, onde \citeonline{uncleBob2017}
    classifica em cinco subprincípios interconectados, tais como: A
    responsabilidade única da classe como entidade; priorização da ação de
    extender sobre a ação de modificar; preservação da relação de substituição
    entre classe base e derivada na herança; A segregação de interfaces como
    forma de evitar construções desnecessárias e, por último, a inversão de
    dependências por contratos abstratos pré-implementados.

    Por outro lado,
    \citeonline{ObjectCalisthenics2008}, em \textit{Object Calisthenics}
    enumera sete pontos pelos quais um sistema conformar-se-á mais com os quatro
    pilares fundamentais do paradigma, onde para o autor surgirá como uma manifestação
    em resposta à má qualidade do código \ac{oop} pré-existente.

    % PADRÕES PROJETO

    No tocante aos padrões de projeto, eles são responsáveis por tratarem a
    forma como as classes/objetos interagem da mesma forma que possuem quatro
    propriedades fundamentais: Um nome padronizado; um problema comum a
    resolver; a especificação geral da solução que resolve ou mitiga o problema
    alvo e as consequências positivas e negativas de adotá-lo \cite[p.~19 et
    al.]{gamma1993design}.

    Neste sentido, cita-se o padrão \textit{Adapter} que, a princípio,
    constitui-se como um objeto cujos os métodos são capazes de traduzir
    chamadas entre código cliente e o código servidor.

%   Distânciar-se mais padrões, por possui escopo muito amplo, e focar em arquiteturas.

    No que tange as arquiteturas de sistemas, aponta-se que houve o aprimoramento contínuo de
    conceitos que promovem desacoplamento por meio da separação de
    responsabilidades. Neste sentido, o objetivo geral se forma das seguintes
    propriedades ideais desejadas, como apontado por \cite[p. 202]{uncleBob2017}:

    \begin{itemize}
      \item{ Arquitetura que independe do frameworks para funcionar. }
      \item{ Regras de negócio podem ser testadas sem interferência de camadas superiores ou inferiores. }
      \item{ Idependência de Interface de Usuário onde ela pode mudar sem interferir o resto do sistema. }
      \item{ Idependência de banco de dados onde sua mudança não interfere nas regras de negócio.  }
      \item{ Independência total das regras de negócio. }
    \end{itemize}

    Notadamente o somatório dessas propriedades,levam ao desenvolvimento
    initerrupto de conceitos, que são promovedores da separação de
    responsabilidades, principalmente em arquiteturas baseadas em camadas.
    Diante do exposto, chegou-se à conclusão universal de que todo o software
    possui, em seu código fonte, dois elementos distinguíveis categoricamente,
    onde cada autor o definiu de formas levemente diferentes.

    \citeonline[p. 51]{evans2004domain} enuncia que o domínio da aplicação
    separa-se das demais camadas que provêem sua funcionalidade..

    \begin{figure}[h]
      \centering
      \caption{ Modelo de Camadas Notáveis em Sistemas de Acordo com \ac{ddd}. }
      \includegraphics[scale=0.8]{lib/layered-ddd.png}
      \source{ Erick Evans 2004 {\imprimirdata}}
      \label{fig:figura}
    \end{figure}

    Semelhantemente, \citeonline{alistairHexagonal2005}, em seu artigo original, define
    um padrão majoritariamente comoposto de classes adaptadoras que possibilitam a separação
    do que ele chamou de "aplicação" do \textit{outside world} "mundo externo".

    \begin{figure}[h]
      \centering
      \caption{ Modelo Hexagonal com Classes Adaptadoras Interligando Domínio e Dependências. }
      \includegraphics[scale=1.2]{lib/hexagonal-original.png}
      \source{ Alistair Cockburn 2005 {\imprimirdata}}
      \label{fig:figura}
    \end{figure}

    Mais a frente \citeonline[p.~189]{uncleBob2017} define categorias separadas
    em \textit{business rules} "regras de negócio" e demais partes satélites
    que possibilitam que tais regras sejam úteis na forma de uma aplicação
    utilizável.

    Neste sentido, seguindo a lógica desses autores, aponta-se que eles tratam
    acerca de um mesmo problema, que possui um conjunto de caracteristicas
    semelhantes e próximas do conceito de dependência. O \textit{software}
    constroi-se envolto em um meio que o permite ser útil ao usuário final
    possuidor das seguintes propriedades

    \begin{itemize}
        \item{ Interfaces gráficas. }
        \item{ Persistência da informação (bancos de dados). }
        \item{ Comunicação entre computadores em redes TCP/IP. }
        \item{ Segurança da informação por criptografia e hashing. }
        \item{ Especificidades da infraestrutura em que a aplicação executa. }
        \item{ Manipulação de dispositivos computacionais de entrada ou saída. }
    \end{itemize}

    Diante do exposto, como forma de fortalecer estes pontos,
    \citeonline[p. 52]{evans2004domain} aponta que o \textit{software} pode, 
    em processos de desenvolvimento descuidados, espalhar as regras do domínio
    de negócios sobre algumas ou todas partes sobrelistadas.

    Apesar dos conceitos apresentados dos parágrafos superiores aparentarem
    ser ótimas, existe, de fato, um criticismo na forma pela qual tais orientações
    podem evoluir em complexidade nos projetos acarretando em problemas de
    complexidade e excesso de engenharia como causa e o desenvolvimento menos
    ágil em função da maior massividade de código fonte como consequência
    \cite{redGreenwp2015}.

    % hexagonal:Alistair Cockburn, livro: Hexagonal Architecture: Ports and Adapters
    % Growing Object Oriented Software with Tests
    % DCI:  James Coplien e Trygve Reenskaug
    % BCE:  Ivar Jacobson, livro: Object Oriented Software Engineering: A Use-Case
    %       Driven Approach.


%   PRINCIPAIS AUTORES
%     Bass, Clements, Kazman ( referência teórica fundamental da arquitetura de software )
%       Software Architecture in Practice
%
%     Robert Cecil Martin (Uncle Bob)
%       Clean Architecture, Implementing clean architecture, Clean architecture with .NET
%
%     Willian Vance
%       Clean Architecture
%     
%     Martin Fowler
%       ?
%
%     Erick Evans ( design de domínio )
%       Domain Driven Design
%     Vaughn Vernon
%       Implementing DDD
%
%     Buschmann et all. ( padrões arquiteturais )
%       Pattern-Oriented Software Architecture


    % ÚLTIMO TÓPICO
    % \input{textuais/capitulo_2/sub-topicos/TrabalhosRelacionados}
\newpage
