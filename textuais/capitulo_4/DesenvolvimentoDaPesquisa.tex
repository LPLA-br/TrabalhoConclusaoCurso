%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%      Desenvolvimento da Pesquisa      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Neste capítulo expõe-se os experimentos da
%% sua pesquisa a proposta de solução da sua
%% pesquisa e em caso do TCC II como ela foi implementada

\section{\textbf{DESENVOLVIMENTO}}
    \label{sec:desenvolvimento-da-pesquisa}
    % remove nome do capítulo do cabeçalho
    %\input{textuais/capitulo_4/sub-topicos/PropostaDeSolucao}

    % para quem foi desenvolvido este sistema ?
    O domínio de negócios do objeto surge como uma solução para gerência
    de processos em ateliês de costura. Em síntese, ele possui características:
    ser local e causar impacto limitado em ambiente informal.

    Em virtude disto, partiu-se do pressuposto de que todo empreendimento de
    costura informal possuiria problemas comuns de ingerência de suas
    informações. Sendo assim, a partir deste pensamento estabeleceu-se um canal
    de comunicação coloquial entre profissional com anos de experiência de
    atuação autônoma na área e programador.

    % qual é o problema ?
    A principiar-se o levantamento de requisitos, se obteve um conjunto de
    caracteristicas que definiu, em confirmação do que fora presumido, um
    \textit{software} voltado para o domínio de costura e conserto de roupas
    deveria ter.

    Como consequência da comunicação inicial, revelou-se situações problemáticas
    onde: os prazos de serviços são esquecidos senão o próprio serviço e suas
    características; o levantamento de custos com insumos usados em confecções
    e concertos não é monitorado.

    Em seguida, partiu-se para escolha das melhores ferramentas para o contexto
    desafiador que delineou-se. Comessou, aqui, a etapa que avalia
    requisitos/aspectos não funcionais da aplicação.

    \citeonline[p.85]{somervilleIam2011} define os requisitos não funcionais
    como sendo aqueles que não atribuem funcionalidades à aplicação, mais 
    são fundamentais para existência dela. Eles são: o ambiente físico,
    as questões de segurança da informação, a capacidade física da máquina
    servidora dentre outros que as circunstâncias possam trazer.

    Assim, o ambiente do sistema, de modo a garantir acessibilidade por
    qualquer rede com acesso a internet, inicialmente fora desenvolvido para
    ser acessível por redes de internet de amplo alcançe, conhecidas como WANs.
    Entretanto, viu-se que essa caracteristica de disponibilidade ampla não
    seria viável devido ao alto custo de infraestrutura de computadores em
    núvem e possíveis problemas legais decorrentes de vazamentos de dados
    \cite{protecaoDados2018}.

    Além disso, considerando o foco experimental assumido, estabeleceu-se o
    ambiente de funcionamento estrito à redes locais LAN cuja disponibilidade
    fica espacialmente restrita ao estabelecimento. Abordagem esta, semelhante
    a encontrada em aplicações anteriores à difusão da acessibilidade da
    internet.

    % ...
    \begin{figure}[h]
      \centering
      \caption{ Diagrama da Infraestrutura Local de Rede Simples. }
      \includegraphics[scale=0.5]{lib/nodes-uml.png}
      \source{ O Autor {\imprimirdata}}
      \label{fig:figura}
    \end{figure}

    %php como linguagem.
    Conseguinte, prosseguiu-se no emprego de uma linguagem de programação
    interpretada cuja caracteristica mais importante fosse a capacidade de
    integrar-se bem com o servidor. Logo figurou-se opções como: Javascript;
    PHP; Python; Ruby; Rust; Go dentre outras. Entretanto, devido ao já largo
    emprego de Javascript, assumiu-se uma alternativa mais tradicional: PHP.
    
    O PHP, que nascera como um conjunto de binários escritos na linguagem C,
    tornou-se, na década de 2000 e 2010, uma das mais utilizadas ferramentas do
    desenvolvimento web backend \cite{phpHistory}. Apesar de seu constante
    declínio atual em face de opções mais modernas, sua influência ainda não é
    negligenciável pois ainda se encontra presente no cerne inúmeras aplicações
    legadas e softwares web \cite{theRegisterPHPDecline}.

    %modelo de classes
    Assumida uma linguagem de programação para implementação do projeto,
    adianta-se para a modelagem do esquema de classes do domínio de negócios.
    Primariamente, o domínio minunciosamente estudado trás as seguintes
    classes fundamentais para solução do problema de negócio.

    \begin{figure}[h]
      \centering
      \caption{ Diagrama Textual Indentado das Classes Principais. }
      \includegraphics[scale=0.8]{lib/classes-principais.png}
      \source{ O Autor {\imprimirdata}}
      \label{fig:figura}
    \end{figure}

    Complementando o diagrama sobreposto, determina-se que "ServiçoCostureira",
    elemento pivô, possui relação de composição de clientes que por sua vez
    agregam classes representantes de seus dados. Por outro lado há a classe
    de Coleção de peças, também parte composta de serviço, que de sua parte
    possui coleção de insumos e seus respectivos dados.

    Em questão de organização de diretórios e sub diretórios, convencionou-se a
    criação da seguinte hierarquia.

    \begin{itemize}
      \item{ Collection - Classes que gerenciam plúrimos objetos. }
      \item{ Entity - Classes que representam Entidades do domínio de negócios. }
      \item{ Service - Classes que implementam casos de uso do sistema instanciadas em main. }
      \item{ Repository - Classes que manipulam banco de dados através de interface padronizada. }
      \item{ Comunication - Classes que usam interface udp/ip para comunicação em redes "\textit{project's specific}". }
      \item{ Enum - Enumerações que representam estados evitando strings mágicas. }
      \item{ ValueObject - Objetos de valor que não são omnirelevantes ao domínio }
    \end{itemize}

    Tal organização orientou-se através de \citeonline{
      goldberg1984smalltalk, evans2004domain, uncleBob2017 }

    No tocante às classes coleções, a obra \citeonline{goldberg1984smalltalk}
    foi de extrema importância na orientação cautelosa de se evitar que objetos
    como peças e insumos possuissem excesso de responsabilidades em manipulando
    matrizes de subobjetos agregados.

    \begin{figure}[h]
      \centering
      \caption{ Classes Coleção. }
      \includegraphics[scale=0.8]{lib/colecoes.png}
      \source{ O Autor {\imprimirdata}}
      \label{fig:figura}
    \end{figure}

    %módulos do PHP e adaptadores
    Com relação às dependências, que são foco do experimento, o PHP possui
    extensões padrões ativáveis na sua configuração. Cada módulo extende sua
    capacidade de modo a permitir que a aplicação possa performar ações
    críticas às funcionalidades instituidas nos requisitos funcionais.

    %pgsql e sockets
    Duas extensões cuja finalidades garatem as capacidades
    de execução de transações \ac{sql} e atendimento do ciclo requisição/resposta
    foram ativadas, respectivamente sendo elas: pgsql e sockets.

    %respectivos adaptadores
    No âmbito dos dados, a ação tomada objetivou a independência da ferramenta
    que manipula o banco de dados através da criação de uma interface, também
    conhecida como contrato abstrato, que definia que classes forasteiras em
    conformidade com tal contrato deveriam possuir quatro métodos fundamentais
    escritos, sendo eles: ler, escrever, redefinir e encerrar.

    Em seguida escreveu-se uma classe do tipo adaptador que implementa o
    sobrecitado contrato. Nela código é capaz de acessar diretamente a
    \ac{api} da extensão pgsl. Ademais, esta abordagem também visou alcançar
    a simplicidade através de um adaptador que pudesse ser universalmente
    utilizado por classes do tipo repositório possuidoras de condigo específico
    de consultas para instânciação de classes de domínio \ac{sql}.

    A posteriori, viu-se as ações assumidas, no contexto dos dados, criaram
    um cenário com características próximas mas não idênticas às expostas por
    \citeonline[p.106]{evans2004domain} na seção que trata acerca de Repositórios.

    \begin{figure}[h]
      \centering
      \caption{ Adaptador de Banco de Dados é, Por Contrato, Substituível. }
      \includegraphics[scale=0.5]{lib/adaptador-dados.png}
      \source{ O Autor {\imprimirdata}}
      \label{fig:figura}
    \end{figure}

    %PARTE EM CONSTRUÇÃO

    Quanto  âmbito da comunicação, não utilizou-se protocolo de aplicação
    em redes conhecido como \ac{http}, como consequência, elaborou-se um protocolo
    próprio construido sobre o \ac{udp}. Trata-se de comandos na forma de substantivo,
    verbo e dados da ação.

    \begin{figure}[h]
      \centering
      \caption{ Exemplos de Comandos do Protocolo Atelie. }
      \includegraphics[scale=0.5]{lib/protocoloatelie.png}
      \source{ O Autor {\imprimirdata}}
      \label{fig:figura}
    \end{figure}
    
    para cada evento de requisição do cliente há ação, por parte do servidor, de
    tratamento do comando, roteamento para caso de uso e resposta.

    Quanto ao módulo dependido para esta funcionalidade a questão da
    independência foi garantida através da implementação de uma classe chamada
    Servidor. Sendo ela implementante de uma interface de mesmo nome que define
    métodos padrões reconhecidos pelo ponto de execução main.php

    \begin{figure}[h]
      \centering
      \caption{ Relação Servidor, IServidor e Main. }
      \includegraphics[scale=0.5]{lib/comunicacao.png}
      \source{ O Autor {\imprimirdata}}
      \label{fig:figura}
    \end{figure}

    %funcionamento geral/ estado do sistema 
    Por fim, conclui-se a etapa de construção onde comunicação e
    dados são agora funcionais e relativamente mais independentes.
    Poder-se-á, agora, extrair resultados e conclusões sobre.

    %\input{textuais/capitulo_4/sub-topicos/Experimentos}
    \newpage
